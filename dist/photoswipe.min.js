/*! PhotoSwipe - v4.1.1 - 2016-06-22
* http://photoswipe.com
* Copyright (c) 2016 Dmitry Semenov; */
!function(a,b){"function"==typeof define&&define.amd?define(b):"object"==typeof exports?module.exports=b():a.PhotoSwipe=b()}(this,function(){"use strict";var a=function(a,b,c,d){/*>>framework-bridge*/
/**
 *
 * Set of generic functions used by gallery.
 * 
 * You're free to modify anything here as long as functionality is kept.
 * 
 */
var e={features:null,bind:function(a,b,c,d){var e=(d?"remove":"add")+"EventListener";b=b.split(" ");for(var f=0;f<b.length;f++)b[f]&&a[e](b[f],c,!1)},isArray:function(a){return a instanceof Array},createEl:function(a,b){var c=document.createElement(b||"div");return a&&(c.className=a),c},getScrollY:function(){var a=window.pageYOffset;return void 0!==a?a:document.documentElement.scrollTop},unbind:function(a,b,c){e.bind(a,b,c,!0)},removeClass:function(a,b){var c=new RegExp("(\\s|^)"+b+"(\\s|$)");a.className=a.className.replace(c," ").replace(/^\s\s*/,"").replace(/\s\s*$/,"")},addClass:function(a,b){e.hasClass(a,b)||(a.className+=(a.className?" ":"")+b)},hasClass:function(a,b){return a.className&&new RegExp("(^|\\s)"+b+"(\\s|$)").test(a.className)},getChildByClass:function(a,b){for(var c=a.firstChild;c;){if(e.hasClass(c,b))return c;c=c.nextSibling}},arraySearch:function(a,b,c){for(var d=a.length;d--;)if(a[d][c]===b)return d;return-1},extend:function(a,b,c){for(var d in b)if(b.hasOwnProperty(d)){if(c&&a.hasOwnProperty(d))continue;a[d]=b[d]}},easing:{sine:{out:function(a){return Math.sin(a*(Math.PI/2))},inOut:function(a){return-(Math.cos(Math.PI*a)-1)/2}},cubic:{out:function(a){return--a*a*a+1}}},/**
	 * 
	 * @return {object}
	 * 
	 * {
	 *  raf : request animation frame function
	 *  caf : cancel animation frame function
	 *  transfrom : transform property key (with vendor), or null if not supported
	 *  oldIE : IE8 or below
	 * }
	 * 
	 */
detectFeatures:function(){if(e.features)return e.features;var a=e.createEl(),b=a.style,c="",d={};
// fix false-positive detection of old Android in new IE
// (IE11 ua string contains "Android 4.0")
if(
// IE8 and below
d.oldIE=document.all&&!document.addEventListener,d.touch="ontouchstart"in window,window.requestAnimationFrame&&(d.raf=window.requestAnimationFrame,d.caf=window.cancelAnimationFrame),d.pointerEvent=navigator.pointerEnabled||navigator.msPointerEnabled,!d.pointerEvent){var f=navigator.userAgent;
// Detect if device is iPhone or iPod and if it's older than iOS 8
// http://stackoverflow.com/a/14223920
// 
// This detection is made because of buggy top/bottom toolbars
// that don't trigger window.resize event.
// For more info refer to _isFixedPosition variable in core.js
if(/iP(hone|od)/.test(navigator.platform)){var g=navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);g&&g.length>0&&(g=parseInt(g[1],10),g>=1&&g<8&&(d.isOldIOSPhone=!0))}
// Detect old Android (before KitKat)
// due to bugs related to position:fixed
// http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript
var h=f.match(/Android\s([0-9\.]*)/),i=h?h[1]:0;i=parseFloat(i),i>=1&&(i<4.4&&(d.isOldAndroid=!0),d.androidVersion=i),d.isMobileOpera=/opera mini|opera mobi/i.test(f)}for(var j,k,l=["transform","perspective","animationName"],m=["","webkit","Moz","ms","O"],n=0;n<4;n++){c=m[n];for(var o=0;o<3;o++)j=l[o],
// uppercase first letter of property name, if vendor is present
k=c+(c?j.charAt(0).toUpperCase()+j.slice(1):j),!d[j]&&k in b&&(d[j]=k);c&&!d.raf&&(c=c.toLowerCase(),d.raf=window[c+"RequestAnimationFrame"],d.raf&&(d.caf=window[c+"CancelAnimationFrame"]||window[c+"CancelRequestAnimationFrame"]))}if(!d.raf){var p=0;d.raf=function(a){var b=(new Date).getTime(),c=Math.max(0,16-(b-p)),d=window.setTimeout(function(){a(b+c)},c);return p=b+c,d},d.caf=function(a){clearTimeout(a)}}
// Detect SVG support
return d.svg=!!document.createElementNS&&!!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,e.features=d,d}};e.detectFeatures(),
// Override addEventListener for old versions of IE
e.features.oldIE&&(e.bind=function(a,b,c,d){b=b.split(" ");for(var e,f=(d?"detach":"attach")+"Event",g=function(){c.handleEvent.call(c)},h=0;h<b.length;h++)if(e=b[h])if("object"==typeof c&&c.handleEvent){if(d){if(!c["oldIE"+e])return!1}else c["oldIE"+e]=g;a[f]("on"+e,c["oldIE"+e])}else a[f]("on"+e,c)});/*>>framework-bridge*/
/*>>core*/
//function(template, UiClass, items, options)
var f=this,g=25,h=3,i={allowPanToNext:!0,spacing:.12,bgOpacity:1,mouseUsed:!1,loop:!0,pinchToClose:!0,closeOnScroll:!0,closeOnVerticalDrag:!0,verticalDragRange:.75,hideAnimationDuration:333,showAnimationDuration:333,showHideOpacity:!1,focus:!0,escKey:!0,arrowKeys:!0,mainScrollEndFriction:.35,panEndFriction:.35,isClickableElement:function(a){return"A"===a.tagName},getDoubleTapZoom:function(a,b){return a?1:b.initialZoomLevel<.7?1:1.33},maxSpreadZoom:1.33,modal:!0,
// not fully implemented yet
scaleMode:"fit"};e.extend(i,d);/**
 * Private helper variables & functions
 */
var j,k,l,m,n,o,p,// drag move, drag end & drag cancel events array
q,// drag start events array
r,s,t,u,v,w,x,// size of slide area, including spacing
y,z,// difference of indexes since last content update
A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,// at least one pointer is down
X,// at least two _pointers are down
Y,// zoom level changed during zoom gesture
Z,$,_,aa,// array of current touch points
ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la,ma,na=function(){return{x:0,y:0}},oa=na(),pa=na(),qa=na(),ra={},sa=0,ta={},ua=na(),va=0,wa=!0,xa=[],ya={},za=!1,Aa=!1,Ba=[],
// Registers PhotoSWipe module (History, Controller ...)
Ca=function(a,b){e.extend(f,b.publicMethods),xa.push(a)},Da=function(a){var b=dc();return a>b-1?a-b:a<0?b+a:a},
// Micro bind/trigger
Ea={},Fa=function(a,b){return Ea[a]||(Ea[a]=[]),Ea[a].push(b)},Ga=function(a){var b=Ea[a];if(b){var c=Array.prototype.slice.call(arguments);c.shift();for(var d=0;d<b.length;d++)b[d].apply(f,c)}},Ha=function(){return(new Date).getTime()},Ia=function(a){ka=a,f.bg.style.opacity=a*i.bgOpacity},Ja=function(a,b,c,d,e){(!za||e&&e!==f.currItem)&&(d/=e?e.fitRatio:f.currItem.fitRatio),a[E]=u+b+"px, "+c+"px"+v+" scale("+d+")"},Ka=function(a){fa&&(a&&(s>f.currItem.fitRatio?za||(pc(f.currItem,!1,!0),za=!0):za&&(pc(f.currItem),za=!1)),Ja(fa,qa.x,qa.y,s))},La=function(a){a.container&&Ja(a.container.style,a.initialPosition.x,a.initialPosition.y,a.initialZoomLevel,a)},Ma=function(a,b){b[E]=u+a+"px, 0px"+v},Na=function(a,b){if(!i.loop&&b){var c=m+(ua.x*sa-a)/ua.x,d=Math.round(a-wb.x);(c<0&&d>0||c>=dc()-1&&d<0)&&(a=wb.x+d*i.mainScrollEndFriction)}wb.x=a,Ma(a,n)},Oa=function(a,b){var c=xb[a]-ta[a];return pa[a]+oa[a]+c-c*(b/t)},Pa=function(a,b){a.x=b.x,a.y=b.y,b.id&&(a.id=b.id)},Qa=function(a){a.x=Math.round(a.x),a.y=Math.round(a.y)},Ra=null,Sa=function(){
// Wait until mouse move event is fired at least twice during 100ms
// We do this, because some mobile browsers trigger it on touchstart
Ra&&(e.unbind(document,"mousemove",Sa),e.addClass(a,"pswp--has_mouse"),i.mouseUsed=!0,Ga("mouseUsed")),Ra=setTimeout(function(){Ra=null},100)},Ta=function(){e.bind(document,"keydown",f),N.transform&&
// don't bind click event in browsers that don't support transform (mostly IE8)
e.bind(f.scrollWrap,"click",f),i.mouseUsed||e.bind(document,"mousemove",Sa),e.bind(window,"resize scroll",f),Ga("bindEvents")},Ua=function(){e.unbind(window,"resize",f),e.unbind(window,"scroll",r.scroll),e.unbind(document,"keydown",f),e.unbind(document,"mousemove",Sa),N.transform&&e.unbind(f.scrollWrap,"click",f),W&&e.unbind(window,p,f),Ga("unbindEvents")},Va=function(a,b){var c=lc(f.currItem,ra,a);return b&&(ea=c),c},Wa=function(a){return a||(a=f.currItem),a.initialZoomLevel},Xa=function(a){return a||(a=f.currItem),a.w>0?i.maxSpreadZoom:1},
// Return true if offset is out of the bounds
Ya=function(a,b,c,d){return d===f.currItem.initialZoomLevel?(c[a]=f.currItem.initialPosition[a],!0):(c[a]=Oa(a,d),c[a]>b.min[a]?(c[a]=b.min[a],!0):c[a]<b.max[a]&&(c[a]=b.max[a],!0))},Za=function(){if(E){
// setup 3d transforms
var b=N.perspective&&!G;return u="translate"+(b?"3d(":"("),void(v=N.perspective?", 0px)":")")}
// Override zoom/pan/move functions in case old browser is used (most likely IE)
// (so they use left/top/width/height, instead of CSS transform)
E="left",e.addClass(a,"pswp--ie"),Ma=function(a,b){b.left=a+"px"},La=function(a){var b=a.fitRatio>1?1:a.fitRatio,c=a.container.style,d=b*a.w,e=b*a.h;c.width=d+"px",c.height=e+"px",c.left=a.initialPosition.x+"px",c.top=a.initialPosition.y+"px"},Ka=function(){if(fa){var a=fa,b=f.currItem,c=b.fitRatio>1?1:b.fitRatio,d=c*b.w,e=c*b.h;a.width=d+"px",a.height=e+"px",a.left=qa.x+"px",a.top=qa.y+"px"}}},$a=function(a){var b="";i.escKey&&27===a.keyCode?b="close":i.arrowKeys&&(37===a.keyCode?b="prev":39===a.keyCode&&(b="next")),b&&(
// don't do anything if special key pressed to prevent from overriding default browser actions
// e.g. in Chrome on Mac cmd+arrow-left returns to previous page
a.ctrlKey||a.altKey||a.shiftKey||a.metaKey||(a.preventDefault?a.preventDefault():a.returnValue=!1,f[b]()))},_a=function(a){a&&(Z||Y||ga||U)&&(a.preventDefault(),a.stopPropagation())},ab=function(){f.setScrollOffset(0,e.getScrollY())},bb={},cb=0,db=function(a){bb[a]&&(bb[a].raf&&I(bb[a].raf),cb--,delete bb[a])},eb=function(a){bb[a]&&db(a),bb[a]||(cb++,bb[a]={})},fb=function(){for(var a in bb)bb.hasOwnProperty(a)&&db(a)},gb=function(a,b,c,d,e,f,g){var h,i=Ha();eb(a);var j=function(){if(bb[a]){// time diff
//b - beginning (start prop)
//d - anim duration
if(h=Ha()-i,h>=d)return db(a),f(c),void(g&&g());f((c-b)*e(h/d)+b),bb[a].raf=H(j)}};j()},hb={
// make a few local variables and functions public
shout:Ga,listen:Fa,viewportSize:ra,options:i,isMainScrollAnimating:function(){return ga},getZoomLevel:function(){return s},getCurrentIndex:function(){return m},isDragging:function(){return W},isZooming:function(){return ba},setScrollOffset:function(a,b){ta.x=a,M=ta.y=b,Ga("updateScrollOffset",ta)},applyZoomPan:function(a,b,c,d){qa.x=b,qa.y=c,s=a,Ka(d)},init:function(){if(!j&&!k){var c;f.framework=e,// basic functionality
f.template=a,// root DOM element of PhotoSwipe
f.bg=e.getChildByClass(a,"pswp__bg"),J=a.className,j=!0,N=e.detectFeatures(),H=N.raf,I=N.caf,E=N.transform,L=N.oldIE,f.scrollWrap=e.getChildByClass(a,"pswp__scroll-wrap"),f.container=e.getChildByClass(f.scrollWrap,"pswp__container"),n=f.container.style,// for fast access
// Objects that hold slides (there are only 3 in DOM)
f.itemHolders=y=[{el:f.container.children[0],wrap:0,index:-1},{el:f.container.children[1],wrap:0,index:-1},{el:f.container.children[2],wrap:0,index:-1}],
// hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)
y[0].el.style.display=y[2].el.style.display="none",Za(),
// Setup global events
r={resize:f.updateSize,scroll:ab,keydown:$a,click:_a};
// disable show/hide effects on old browsers that don't support CSS animations or transforms,
// old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.
var d=N.isOldIOSPhone||N.isOldAndroid||N.isMobileOpera;
// init modules
for(N.animationName&&N.transform&&!d||(i.showAnimationDuration=i.hideAnimationDuration=0),c=0;c<xa.length;c++)f["init"+xa[c]]();
// init
if(b){var g=f.ui=new b(f,e);g.init()}Ga("firstUpdate"),m=m||i.index||0,
// validate index
(isNaN(m)||m<0||m>=dc())&&(m=0),f.currItem=cc(m),(N.isOldIOSPhone||N.isOldAndroid)&&(wa=!1),a.setAttribute("aria-hidden","false"),i.modal&&(wa?a.style.position="fixed":(a.style.position="absolute",a.style.top=e.getScrollY()+"px")),void 0===M&&(Ga("initialLayout"),M=K=e.getScrollY());
// add classes to root element of PhotoSwipe
var l="pswp--open ";for(i.mainClass&&(l+=i.mainClass+" "),i.showHideOpacity&&(l+="pswp--animate_opacity "),l+=G?"pswp--touch":"pswp--notouch",l+=N.animationName?" pswp--css_animation":"",l+=N.svg?" pswp--svg":"",e.addClass(a,l),f.updateSize(),
// initial update
o=-1,va=null,c=0;c<h;c++)Ma((c+o)*ua.x,y[c].el.style);L||e.bind(f.scrollWrap,q,f),Fa("initialZoomInEnd",function(){f.setContent(y[0],m-1),f.setContent(y[2],m+1),y[0].el.style.display=y[2].el.style.display="block",i.focus&&
// focus causes layout,
// which causes lag during the animation,
// that's why we delay it untill the initial zoom transition ends
a.focus(),Ta()}),
// set content for center slide (first time)
f.setContent(y[1],m),f.updateCurrItem(),Ga("afterInit"),f.setLoopFirstLastFinal(),wa||(
// On all versions of iOS lower than 8.0, we check size of viewport every second.
//
// This is done to detect when Safari top & bottom bars appear,
// as this action doesn't trigger any events (like resize).
//
// On iOS8 they fixed this.
//
// 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.
w=setInterval(function(){cb||W||ba||s!==f.currItem.initialZoomLevel||f.updateSize()},1e3)),e.addClass(a,"pswp--visible")}},
// Close the gallery, then destroy it
close:function(){j&&(j=!1,k=!0,Ga("close"),Ua(),fc(f.currItem,null,!0,f.destroy))},
// destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)
destroy:function(){Ga("destroy"),$b&&clearTimeout($b),a.setAttribute("aria-hidden","true"),a.className=J,w&&clearInterval(w),e.unbind(f.scrollWrap,q,f),
// we unbind scroll event at the end, as closing animation may depend on it
e.unbind(window,"scroll",f),Cb(),fb(),Ea=null},/**
	 * Pan image to position
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Boolean} force Will ignore bounds if set to true.
	 */
panTo:function(a,b,c){c||(a>ea.min.x?a=ea.min.x:a<ea.max.x&&(a=ea.max.x),b>ea.min.y?b=ea.min.y:b<ea.max.y&&(b=ea.max.y)),qa.x=a,qa.y=b,Ka()},handleEvent:function(a){a=a||window.event,r[a.type]&&r[a.type](a)},goTo:function(a){a=Da(a);var b=a-m;va=b,m=a,f.currItem=cc(m),sa-=b,Na(ua.x*sa),fb(),ga=!1,f.updateCurrItem()},next:function(){P||f.goTo(m+1)},prev:function(){O||f.goTo(m-1)},
// update current zoom/pan objects
updateCurrZoomItem:function(a){
// itemHolder[1] is middle (current) item
if(a&&Ga("beforeChange",0),y[1].el.children.length){var b=y[1].el.children[0];fa=e.hasClass(b,"pswp__zoom-wrap")?b.style:null}else fa=null;ea=f.currItem.bounds,t=s=f.currItem.initialZoomLevel,qa.x=ea.center.x,qa.y=ea.center.y,a&&f.setLoopFirstLastFinal()},invalidateCurrItems:function(){x=!0;for(var a=0;a<h;a++)y[a].item&&(y[a].item.needsUpdate=!0)},updateCurrItem:function(a){if(0!==va){var b,c=Math.abs(va);if(!(a&&c<2)){f.currItem=cc(m),za=!1,Ga("beforeChange",va),c>=h&&(o+=va+(va>0?-h:h),c=h);for(var d=0;d<c;d++)va>0?(b=y.shift(),y[h-1]=b,// move first to last
o++,Ma((o+2)*ua.x,b.el.style),f.setContent(b,m-c+d+1+1)):(b=y.pop(),y.unshift(b),// move last to first
o--,Ma(o*ua.x,b.el.style),f.setContent(b,m+c-d-1-1));
// reset zoom/pan on previous item
if(fa&&1===Math.abs(va)){var e=cc(z);e.initialZoomLevel!==s&&(lc(e,ra),pc(e),La(e))}
// reset diff after update
va=0,f.updateCurrZoomItem(),z=m,f.setLoopFirstLastFinal()}}},setLoopFirstLastFinal:function(){if(i.loop===!1)P=m+1===f.items.length,O=0===m;else{if("once"!==i.loop)return;// loops thru all slides once starting from any slide, then marks to close
Aa=Ba.length===f.items.length,Ga("afterChange")}},updateSize:function(b){if(!wa&&i.modal){var c=e.getScrollY();if(M!==c&&(a.style.top=c+"px",M=c),!b&&ya.x===window.innerWidth&&ya.y===window.innerHeight)return;ya.x=window.innerWidth,ya.y=window.innerHeight,
//template.style.width = _windowVisibleSize.x + 'px';
a.style.height=ya.y+"px"}// even may be used for example to switch image sources
// don't re-calculate size on inital size update
if(ra.x=f.scrollWrap.clientWidth,ra.y=f.scrollWrap.clientHeight,ab(),ua.x=ra.x+Math.round(ra.x*i.spacing),ua.y=ra.y,Na(ua.x*sa),Ga("beforeResize"),void 0!==o){for(var d,g,j,k=0;k<h;k++)d=y[k],Ma((k+o)*ua.x,d.el.style),j=m+k-1,i.loop&&dc()>2&&(j=Da(j)),
// update zoom level on items and refresh source (if needsUpdate)
g=cc(j),
// re-render gallery item if `needsUpdate`,
// or doesn't have `bounds` (entirely new slide object)
g&&(x||g.needsUpdate||!g.bounds)?(f.cleanSlide(g),f.setContent(d,j),
// if "center" slide
1===k&&(f.currItem=g,f.updateCurrZoomItem(!0)),g.needsUpdate=!1):d.index===-1&&j>=0&&
// add content first time
f.setContent(d,j),g&&g.container&&(lc(g,ra),pc(g),La(g));x=!1}t=s=f.currItem.initialZoomLevel,ea=f.currItem.bounds,ea&&(qa.x=ea.center.x,qa.y=ea.center.y,Ka(!0)),Ga("resize")},
// Zoom current item to
zoomTo:function(a,b,c,d,f){/*
			if(destZoomLevel === 'fit') {
				destZoomLevel = self.currItem.fitRatio;
			} else if(destZoomLevel === 'fill') {
				destZoomLevel = self.currItem.fillRatio;
			}
		*/
b&&(t=s,xb.x=Math.abs(b.x)-qa.x,xb.y=Math.abs(b.y)-qa.y,Pa(pa,qa));var g=Va(a,!1),h={};Ya("x",g,h,a),Ya("y",g,h,a);var i=s,j={x:qa.x,y:qa.y};Qa(h);var k=function(b){1===b?(s=a,qa.x=h.x,qa.y=h.y):(s=(a-i)*b+i,qa.x=(h.x-j.x)*b+j.x,qa.y=(h.y-j.y)*b+j.y),f&&f(b),Ka(1===b)};c?gb("customZoomTo",0,1,c,d||e.easing.sine.inOut,k):k(1)}},ib=30,jb=10,
// pool of objects that are used during dragging of zooming
kb={},// first point
lb={},// second point (for zoom gesture)
mb={},nb={},ob={},pb=[],qb={},rb=[],// array of points during dragging, used to determine type of gesture
sb={},tb=0,ub=na(),vb=0,wb=na(),// true, if animation after swipe gesture is running
xb=na(),yb=na(),zb=function(a,b){return a.x===b.x&&a.y===b.y},Ab=function(a,b){return Math.abs(a.x-b.x)<g&&Math.abs(a.y-b.y)<g},Bb=function(a,b){return sb.x=Math.abs(a.x-b.x),sb.y=Math.abs(a.y-b.y),Math.sqrt(sb.x*sb.x+sb.y*sb.y)},Cb=function(){$&&(I($),$=null)},Db=function(){W&&($=H(Db),Tb())},Eb=function(){return!("fit"===i.scaleMode&&s===f.currItem.initialZoomLevel)},
// find the closest parent DOM element
Fb=function(a,b){
// don't search elements above pswp__scroll-wrap
return!(!a||a===document)&&(!(a.getAttribute("class")&&a.getAttribute("class").indexOf("pswp__scroll-wrap")>-1)&&(b(a)?a:Fb(a.parentNode,b)))},Gb={},Hb=function(a,b){return Gb.prevent=!Fb(a.target,i.isClickableElement),Ga("preventDragEvent",a,b,Gb),Gb.prevent},Ib=function(a,b){return b.x=a.pageX,b.y=a.pageY,b.id=a.identifier,b},Jb=function(a,b,c){c.x=.5*(a.x+b.x),c.y=.5*(a.y+b.y)},Kb=function(a,b,c){if(a-R>50){var d=rb.length>2?rb.shift():{};d.x=b,d.y=c,rb.push(d),R=a}},Lb=function(){var a=qa.y-f.currItem.initialPosition.y;// difference between initial and current position
return 1-Math.abs(a/(ra.y/2))},
// points pool, reused during touch events
Mb={},Nb={},Ob=[],Pb=function(a){
// clean up previous points, without recreating array
for(;Ob.length>0;)Ob.pop();
// we can use forEach, as pointer events are supported only in modern browsers
return F?(ma=0,pb.forEach(function(a){0===ma?Ob[0]=a:1===ma&&(Ob[1]=a),ma++})):a.type.indexOf("touch")>-1?a.touches&&a.touches.length>0&&(Ob[0]=Ib(a.touches[0],Mb),a.touches.length>1&&(Ob[1]=Ib(a.touches[1],Nb))):(Mb.x=a.pageX,Mb.y=a.pageY,Mb.id="",Ob[0]=Mb),Ob},Qb=function(a,b){var c,d,e,g,h=0,j=qa[a]+b[a],k=b[a]>0,l=wb.x+b.x,m=wb.x-qb.x;
// move main scroll or start panning
// calculate fdistance over the bounds and friction
// move main scroll or start panning
// drag right
return c=j>ea.min[a]||j<ea.max[a]?i.panEndFriction:1,j=qa[a]+b[a]*c,!i.allowPanToNext&&s!==f.currItem.initialZoomLevel||(fa?"h"!==ha||"x"!==a||Y||(k?(j>ea.min[a]&&(c=i.panEndFriction,h=ea.min[a]-j,d=ea.min[a]-pa[a]),(d<=0||m<0)&&dc()>1?(g=l,m<0&&l>qb.x&&(g=qb.x)):ea.min.x!==ea.max.x&&(e=j)):(j<ea.max[a]&&(c=i.panEndFriction,h=j-ea.max[a],d=pa[a]-ea.max[a]),(d<=0||m>0)&&dc()>1?(g=l,m>0&&l<qb.x&&(g=qb.x)):ea.min.x!==ea.max.x&&(e=j))):g=l,"x"!==a)?void(ga||_||s>f.currItem.fitRatio&&(qa[a]+=b[a]*c)):(void 0!==g&&(Na(g,!0),_=g!==qb.x),ea.min.x!==ea.max.x&&(void 0!==e?qa.x=e:_||(qa.x+=b.x*c)),void 0!==g)},
// Pointerdown/touchstart/mousedown handler
Rb=function(a){
// Allow dragging only via left mouse button.
// As this handler is not added in IE8 - we ignore e.which
// 
// http://www.quirksmode.org/js/events_properties.html
// https://developer.mozilla.org/en-US/docs/Web/API/event.button
if(!("mousedown"===a.type&&a.button>0)){if(bc)return void a.preventDefault();if(!V||"mousedown"!==a.type){if(Hb(a,!0)&&a.preventDefault(),Ga("pointerDown"),F){var b=e.arraySearch(pb,a.pointerId,"id");b<0&&(b=pb.length),pb[b]={x:a.pageX,y:a.pageY,id:a.pointerId}}var c=Pb(a),d=c.length;aa=null,fb(),
// init drag
W&&1!==d||(W=ia=!0,e.bind(window,p,f),T=la=ja=U=_=Z=X=Y=!1,ha=null,Ga("firstTouchStart",c),Pa(pa,qa),oa.x=oa.y=0,Pa(nb,c[0]),Pa(ob,nb),
//_equalizePoints(_startMainScrollPos, _mainScrollPos);
qb.x=ua.x*sa,rb=[{x:nb.x,y:nb.y}],R=Q=Ha(),
//_mainScrollAnimationEnd(true);
Va(s,!0),
// Start rendering
Cb(),Db()),
// init zoom
!ba&&d>1&&!ga&&!_&&(t=s,Y=!1,// true if zoom changed at least once
ba=X=!0,oa.y=oa.x=0,Pa(pa,qa),Pa(kb,c[0]),Pa(lb,c[1]),Jb(kb,lb,yb),xb.x=Math.abs(yb.x)-qa.x,xb.y=Math.abs(yb.y)-qa.y,ca=da=Bb(kb,lb))}}},
// Pointermove/touchmove/mousemove handler
Sb=function(a){if(a.preventDefault(),F){var b=e.arraySearch(pb,a.pointerId,"id");if(b>-1){var c=pb[b];c.x=a.pageX,c.y=a.pageY}}if(W){var d=Pb(a);if(ha||Z||ba)aa=d;else if(wb.x!==ua.x*sa)
// if main scroll position is shifted â€“ direction is always horizontal
ha="h";else{var f=Math.abs(d[0].x-nb.x)-Math.abs(d[0].y-nb.y);
// check the direction of movement
Math.abs(f)>=jb&&(ha=f>0?"h":"v",aa=d)}}},
// 
Tb=function(){if(aa){var a=aa.length;if(0!==a)if(Pa(kb,aa[0]),mb.x=kb.x-nb.x,mb.y=kb.y-nb.y,ba&&a>1){
// check if one of two points changed
if(
// Handle behaviour for more than 1 point
nb.x=kb.x,nb.y=kb.y,!mb.x&&!mb.y&&zb(aa[1],lb))return;Pa(lb,aa[1]),Y||(Y=!0,Ga("zoomGestureStarted"));
// Distance between two points
var b=Bb(kb,lb),c=Yb(b);
// slightly over the of initial zoom level
c>f.currItem.initialZoomLevel+f.currItem.initialZoomLevel/15&&(la=!0);
// Apply the friction if zoom level is out of the bounds
var d=1,e=Wa(),g=Xa();if(c<e)if(i.pinchToClose&&!la&&t<=f.currItem.initialZoomLevel){
// fade out background if zooming out
var h=e-c,j=1-h/(e/1.2);Ia(j),Ga("onPinchClose",j),ja=!0}else d=(e-c)/e,d>1&&(d=1),c=e-d*(e/3);else c>g&&(
// 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5
d=(c-g)/(6*e),d>1&&(d=1),c=g+d*e);d<0&&(d=0),
// distance between touch points after friction is applied
ca=b,
// _centerPoint - The point in the middle of two pointers
Jb(kb,lb,ub),
// paning with two pointers pressed
oa.x+=ub.x-yb.x,oa.y+=ub.y-yb.y,Pa(yb,ub),qa.x=Oa("x",c),qa.y=Oa("y",c),T=c>s,s=c,Ka()}else{
// handle behaviour for one point (dragging or panning)
if(!ha)return;
// do nothing if pointers position hasn't changed
if(ia&&(ia=!1,
// subtract drag distance that was used during the detection direction  
Math.abs(mb.x)>=jb&&(mb.x-=aa[0].x-ob.x),Math.abs(mb.y)>=jb&&(mb.y-=aa[0].y-ob.y)),nb.x=kb.x,nb.y=kb.y,0===mb.x&&0===mb.y)return;if("v"===ha&&i.closeOnVerticalDrag&&!Eb()){oa.y+=mb.y,qa.y+=mb.y;var k=Lb();return U=!0,Ga("onVerticalDrag",k),Ia(k),void Ka()}Kb(Ha(),kb.x,kb.y),Z=!0,ea=f.currItem.bounds;var l=Qb("x",mb);l||(Qb("y",mb),Qa(qa),Ka())}}},
// Pointerup/pointercancel/touchend/touchcancel/mouseup event handler
Ub=function(a){if(N.isOldAndroid){if(V&&"mouseup"===a.type)return;
// on Android (v4.1, 4.2, 4.3 & possibly older) 
// ghost mousedown/up event isn't preventable via e.preventDefault,
// which causes fake mousedown event
// so we block mousedown/up for 600ms
a.type.indexOf("touch")>-1&&(clearTimeout(V),V=setTimeout(function(){V=0},600))}Ga("pointerUp"),Hb(a,!1)&&a.preventDefault();var b;if(F){var c=e.arraySearch(pb,a.pointerId,"id");if(c>-1)if(b=pb.splice(c,1)[0],navigator.pointerEnabled)b.type=a.pointerType||"mouse";else{var d={4:"mouse",// event.MSPOINTER_TYPE_MOUSE
2:"touch",// event.MSPOINTER_TYPE_TOUCH 
3:"pen"};b.type=d[a.pointerType],b.type||(b.type=a.pointerType||"mouse")}}var g,h=Pb(a),j=h.length;
// Do nothing if there were 3 touch points or more
if("mouseup"===a.type&&(j=0),2===j)return aa=null,!0;
// if second pointer released
1===j&&Pa(ob,h[0]),
// pointer hasn't moved, send "tap release" point
0!==j||ha||ga||(b||("mouseup"===a.type?b={x:a.pageX,y:a.pageY,type:"mouse"}:a.changedTouches&&a.changedTouches[0]&&(b={x:a.changedTouches[0].pageX,y:a.changedTouches[0].pageY,type:"touch"})),Ga("touchRelease",a,b));
// Difference in time between releasing of two last touch points (zoom gesture)
var k=-1;if(
// Gesture completed, no pointers left
0===j&&(W=!1,e.unbind(window,p,f),Cb(),ba?
// Two points released at the same time
k=0:vb!==-1&&(k=Ha()-vb)),vb=1===j?Ha():-1,g=k!==-1&&k<150?"zoom":"swipe",ba&&j<2&&(ba=!1,
// Only second point released
1===j&&(g="zoomPointerUp"),Ga("zoomGestureEnded")),aa=null,Z||Y||ga||U)if(fb(),S||(S=Vb()),S.calculateSwipeSpeed("x"),U){var l=Lb();if(l<i.verticalDragRange)f.close();else{var m=qa.y,n=ka;gb("verticalDrag",0,1,300,e.easing.cubic.out,function(a){qa.y=(f.currItem.initialPosition.y-m)*a+m,Ia((1-n)*a+n),Ka()}),Ga("onVerticalDrag",1)}}else{
// main scroll 
if((_||ga)&&0===j){var o=Xb(g,S);if(o)return;g="zoomPointerUp"}
// prevent zoom/pan animation when main scroll animation runs
if(!ga)
// Complete simple zoom gesture (reset zoom level if it's out of the bounds)  
// Complete simple zoom gesture (reset zoom level if it's out of the bounds)  
// Complete pan gesture if main scroll is not shifted, and it's possible to pan current image
return"swipe"!==g?void Zb():void(!_&&s>f.currItem.fitRatio&&Wb(S))}},
// Returns object with data about gesture
// It's created only once and then reused
Vb=function(){
// temp local vars
var a,b,c={lastFlickOffset:{},lastFlickDist:{},lastFlickSpeed:{},slowDownRatio:{},slowDownRatioReverse:{},speedDecelerationRatio:{},speedDecelerationRatioAbs:{},distanceOffset:{},backAnimDestination:{},backAnimStarted:{},calculateSwipeSpeed:function(d){rb.length>1?(a=Ha()-R+50,b=rb[rb.length-2][d]):(a=Ha()-Q,// total gesture duration
b=ob[d]),c.lastFlickOffset[d]=nb[d]-b,c.lastFlickDist[d]=Math.abs(c.lastFlickOffset[d]),c.lastFlickDist[d]>20?c.lastFlickSpeed[d]=c.lastFlickOffset[d]/a:c.lastFlickSpeed[d]=0,Math.abs(c.lastFlickSpeed[d])<.1&&(c.lastFlickSpeed[d]=0),c.slowDownRatio[d]=.95,c.slowDownRatioReverse[d]=1-c.slowDownRatio[d],c.speedDecelerationRatio[d]=1},calculateOverBoundsAnimOffset:function(a,b){c.backAnimStarted[a]||(qa[a]>ea.min[a]?c.backAnimDestination[a]=ea.min[a]:qa[a]<ea.max[a]&&(c.backAnimDestination[a]=ea.max[a]),void 0!==c.backAnimDestination[a]&&(c.slowDownRatio[a]=.7,c.slowDownRatioReverse[a]=1-c.slowDownRatio[a],c.speedDecelerationRatioAbs[a]<.05&&(c.lastFlickSpeed[a]=0,c.backAnimStarted[a]=!0,gb("bounceZoomPan"+a,qa[a],c.backAnimDestination[a],b||300,e.easing.sine.out,function(b){qa[a]=b,Ka()}))))},
// Reduces the speed by slowDownRatio (per 10ms)
calculateAnimOffset:function(a){c.backAnimStarted[a]||(c.speedDecelerationRatio[a]=c.speedDecelerationRatio[a]*(c.slowDownRatio[a]+c.slowDownRatioReverse[a]-c.slowDownRatioReverse[a]*c.timeDiff/10),c.speedDecelerationRatioAbs[a]=Math.abs(c.lastFlickSpeed[a]*c.speedDecelerationRatio[a]),c.distanceOffset[a]=c.lastFlickSpeed[a]*c.speedDecelerationRatio[a]*c.timeDiff,qa[a]+=c.distanceOffset[a])},panAnimLoop:function(){if(bb.zoomPan&&(bb.zoomPan.raf=H(c.panAnimLoop),c.now=Ha(),c.timeDiff=c.now-c.lastNow,c.lastNow=c.now,c.calculateAnimOffset("x"),c.calculateAnimOffset("y"),Ka(),c.calculateOverBoundsAnimOffset("x"),c.calculateOverBoundsAnimOffset("y"),c.speedDecelerationRatioAbs.x<.05&&c.speedDecelerationRatioAbs.y<.05))
// round pan position
return qa.x=Math.round(qa.x),qa.y=Math.round(qa.y),Ka(),void db("zoomPan")}};return c},Wb=function(a){
// Avoid acceleration animation if speed is too low
// calculate swipe speed for Y axis (paanning)
// Avoid acceleration animation if speed is too low
// Run pan drag release animation. E.g. if you drag image and release finger without momentum.
// Animation loop that controls the acceleration after pan gesture ends
return a.calculateSwipeSpeed("y"),ea=f.currItem.bounds,a.backAnimDestination={},a.backAnimStarted={},Math.abs(a.lastFlickSpeed.x)<=.05&&Math.abs(a.lastFlickSpeed.y)<=.05?(a.speedDecelerationRatioAbs.x=a.speedDecelerationRatioAbs.y=0,a.calculateOverBoundsAnimOffset("x"),a.calculateOverBoundsAnimOffset("y"),!0):(eb("zoomPan"),a.lastNow=Ha(),void a.panAnimLoop())},Xb=function(a,b){var c;ga||(tb=m);var d;if("swipe"===a){var g=nb.x-ob.x,h=b.lastFlickDist.x<10;
// if container is shifted for more than MIN_SWIPE_DISTANCE, 
// and last flick gesture was in right direction
g>ib&&(h||b.lastFlickOffset.x>20)?
// go to prev item
d=-1:g<-ib&&(h||b.lastFlickOffset.x<-20)&&(
// go to next item
d=1)}var j;d&&(m+=d,m<0?(m=i.loop?dc()-1:0,j=!0):m>=dc()&&(m=i.loop?0:dc()-1,j=!0),j&&!i.loop||(va+=d,sa-=d,c=!0));var k,l=ua.x*sa,n=Math.abs(l-wb.x);
// "return to current" duration, e.g. when dragging from slide 0 to -1
return c||l>wb.x==b.lastFlickSpeed.x>0?(k=Math.abs(b.lastFlickSpeed.x)>0?n/Math.abs(b.lastFlickSpeed.x):333,k=Math.min(k,400),k=Math.max(k,250)):k=333,tb===m&&(c=!1),ga=!0,Ga("mainScrollAnimStart"),gb("mainScroll",wb.x,l,k,e.easing.cubic.out,Na,function(){fb(),ga=!1,tb=-1,(c||tb!==m)&&f.updateCurrItem(),Ga("mainScrollAnimComplete")}),c&&f.updateCurrItem(!0),c},Yb=function(a){return 1/da*a*t},
// Resets zoom if it's out of bounds
Zb=function(){var a=s,b=Wa(),c=Xa();s<b?a=b:s>c&&(a=c);var d,g=1,h=ka;
//_closedByScroll = true;
return ja&&!T&&!la&&s<b?(f.close(),!0):(ja&&(d=function(a){Ia((g-h)*a+h)}),f.zoomTo(a,0,200,e.easing.cubic.out,d),!0)};Ca("Gestures",{publicMethods:{initGestures:function(){
// helper function that builds touch/pointer/mouse events
var a=function(a,b,c,d,e){A=a+b,B=a+c,C=a+d,D=e?a+e:""};F=N.pointerEvent,F&&N.touch&&(
// we don't need touch events, if browser supports pointer events
N.touch=!1),F?navigator.pointerEnabled?a("pointer","down","move","up","cancel"):
// IE10 pointer events are case-sensitive
a("MSPointer","Down","Move","Up","Cancel"):N.touch?(a("touch","start","move","end","cancel"),G=!0):a("mouse","down","move","up"),p=B+" "+C+" "+D,q=A,F&&!G&&(G=navigator.maxTouchPoints>1||navigator.msMaxTouchPoints>1),
// make variable public
f.likelyTouchDevice=G,r[A]=Rb,r[B]=Sb,r[C]=Ub,// the Kraken
D&&(r[D]=r[C]),
// Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.
N.touch&&(q+=" mousedown",p+=" mousemove mouseup",r.mousedown=r[A],r.mousemove=r[B],r.mouseup=r[C]),G||(
// don't allow pan to next slide from zoomed state on Desktop
i.allowPanToNext=!1)}}});/*>>gestures*/
/*>>show-hide-transition*/
/**
 * show-hide-transition.js:
 *
 * Manages initial opening or closing transition.
 *
 * If you're not planning to use transition for gallery at all,
 * you may set options hideAnimationDuration and showAnimationDuration to 0,
 * and just delete startAnimation function.
 * 
 */
var $b,_b,ac,bc,cc,dc,ec,fc=function(b,c,d,g){$b&&clearTimeout($b),bc=!0,ac=!0;
// dimensions of small thumbnail {x:,y:,w:}.
// Height is optional, as calculated based on large image.
var h;b.initialLayout?(h=b.initialLayout,b.initialLayout=null):h=i.getThumbBoundsFn&&i.getThumbBoundsFn(m);var j=d?i.hideAnimationDuration:i.showAnimationDuration,k=function(){db("initialZoom"),d?(f.template.removeAttribute("style"),f.bg.removeAttribute("style")):(Ia(1),c&&(c.style.display="block"),e.addClass(a,"pswp--animated-in"),Ga("initialZoom"+(d?"OutEnd":"InEnd"))),g&&g(),bc=!1};
// if bounds aren't provided, just open gallery without animation
if(!j||!h||void 0===h.x)return Ga("initialZoom"+(d?"Out":"In")),s=b.initialZoomLevel,Pa(qa,b.initialPosition),Ka(),a.style.opacity=d?0:1,Ia(1),void(j?setTimeout(function(){k()},j):k());var n=function(){var c=l,g=!f.currItem.src||f.currItem.loadError||i.showHideOpacity;
// apply hw-acceleration to image
b.miniImg&&(b.miniImg.style.webkitBackfaceVisibility="hidden"),d||(s=h.w/b.w,qa.x=h.x,qa.y=h.y-K,f[g?"template":"bg"].style.opacity=.001,Ka()),eb("initialZoom"),d&&!c&&e.removeClass(a,"pswp--animated-in"),g&&(d?e[(c?"remove":"add")+"Class"](a,"pswp--animate_opacity"):setTimeout(function(){e.addClass(a,"pswp--animate_opacity")},30)),$b=setTimeout(function(){if(Ga("initialZoom"+(d?"Out":"In")),d){
// "out" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position
var f=h.w/b.w,i={x:qa.x,y:qa.y},l=s,m=ka,n=function(b){1===b?(s=f,qa.x=h.x,qa.y=h.y-M):(s=(f-l)*b+l,qa.x=(h.x-i.x)*b+i.x,qa.y=(h.y-M-i.y)*b+i.y),Ka(),g?a.style.opacity=1-b:Ia(m-b*m)};c?gb("initialZoom",0,1,j,e.easing.cubic.out,n,k):(n(1),$b=setTimeout(k,j+20))}else
// "in" animation always uses CSS transitions (instead of rAF).
// CSS transition work faster here, 
// as developer may also want to animate other things, 
// like ui on top of sliding area, which can be animated just via CSS
s=b.initialZoomLevel,Pa(qa,b.initialPosition),Ka(),Ia(1),g?a.style.opacity=1:Ia(1),$b=setTimeout(k,j+20)},d?25:90)};n()},gc={},hc=[],ic={index:0,errorMsg:'<div class="pswp__error-msg"><a href="%url%" target="_blank">The image</a> could not be loaded.</div>',forceProgressiveLoading:!1,// TODO
preload:[1,1],getNumItemsFn:function(){return _b.length}},jc=function(){return{center:{x:0,y:0},max:{x:0,y:0},min:{x:0,y:0}}},kc=function(a,b,c){var d=a.bounds;
// position of element when it's centered
d.center.x=Math.round((gc.x-b)/2),d.center.y=Math.round((gc.y-c)/2)+a.vGap.top,
// maximum pan position
d.max.x=b>gc.x?Math.round(gc.x-b):d.center.x,d.max.y=c>gc.y?Math.round(gc.y-c)+a.vGap.top:d.center.y,
// minimum pan position
d.min.x=b>gc.x?0:d.center.x,d.min.y=c>gc.y?a.vGap.top:d.center.y},lc=function(a,b,c){if(a.src&&!a.loadError){var d=!c;if(d&&(a.vGap||(a.vGap={top:0,bottom:0}),
// allows overriding vertical margin for individual items
Ga("parseVerticalMargin",a)),gc.x=b.x,gc.y=b.y-a.vGap.top-a.vGap.bottom,d){var e=gc.x/a.w,f=gc.y/a.h;a.fitRatio=e<f?e:f;
//item.fillRatio = hRatio > vRatio ? hRatio : vRatio;
var g=i.scaleMode;"orig"===g?c=1:"fit"===g&&(c=a.fitRatio),c>1&&(c=1),a.initialZoomLevel=c,a.bounds||(
// reuse bounds object
a.bounds=jc())}if(!c)return;return kc(a,a.w*c,a.h*c),d&&c===a.initialZoomLevel&&(a.initialPosition=a.bounds.center),a.bounds}
// if it's not image, we return zero bounds (content is not zoomable)
return a.w=a.h=0,a.initialZoomLevel=a.fitRatio=1,a.bounds=jc(),a.initialPosition=a.bounds.center,a.bounds},mc=function(a,b,c,d,e,g){b.loadError||d&&(b.imageAppended=!0,pc(b,d,b===f.currItem&&za),c.appendChild(d),g&&setTimeout(function(){b&&b.loaded&&b.placeholder&&(b.placeholder.style.display="none",b.placeholder=null)},500))},nc=function(a){a.loading=!0,a.loaded=!1;var b=a.img=e.createEl("pswp__img","img"),c=function(){a.loading=!1,a.loaded=!0,a.loadComplete?a.loadComplete(a):a.img=null,b.onload=b.onerror=null,b=null};// + '?a=' + Math.random();
return b.onload=c,b.onerror=function(){a.loadError=!0,c()},b.src=a.src,b},oc=function(a,b){if(a.src&&a.loadError&&a.container)return b&&(a.container.innerHTML=""),a.container.innerHTML=i.errorMsg.replace("%url%",a.src),!0},pc=function(a,b,c){if(a.src){b||(b=a.container.lastChild);var d=c?a.w:Math.round(a.w*a.fitRatio),e=c?a.h:Math.round(a.h*a.fitRatio);a.placeholder&&!a.loaded&&(a.placeholder.style.width=d+"px",a.placeholder.style.height=e+"px"),b.style.width=d+"px",b.style.height=e+"px"}},qc=function(){if(hc.length){for(var a,b=0;b<hc.length;b++)a=hc[b],a.holder.index===a.index&&mc(a.index,a.item,a.baseDiv,a.img,!1,a.clearPlaceholder);hc=[]}};Ca("Controller",{publicMethods:{lazyLoadItem:function(a){a=Da(a);var b=cc(a);b&&(!b.loaded&&!b.loading||x)&&(Ga("gettingData",a,b),b.src&&nc(b))},initController:function(){e.extend(i,ic,!0),f.items=_b=c,cc=f.getItemAt,dc=i.getNumItemsFn,//self.getNumItems;
ec=i.loop,dc()<3&&(i.loop=!1),Fa("beforeChange",function(a){
//if finalFrame and firstViewed { close }
var b,c=i.preload,d=null===a||a>=0,e=Math.min(c[0],dc()),g=Math.min(c[1],dc());for(b=1;b<=(d?g:e);b++)f.lazyLoadItem(m+b);for(b=1;b<=(d?e:g);b++)f.lazyLoadItem(m-b)}),Fa("afterChange",function(){var a=f.getCurrentIndex(),b=Ba[0],c=Ba[Ba.length-1];console.log("currSlide: "+a+" initialSlide: "+b+" endingSlide: "+c),Aa&&(// if seen all slides
a!==b&&a!==c||// if back to initial or final slide
setTimeout(function(){// lets PSWP tidy up before closing
f.close()},100)),Ba.indexOf(a)>=0||Ba.push(a)}),Fa("initialLayout",function(){f.currItem.initialLayout=i.getThumbBoundsFn&&i.getThumbBoundsFn(m)}),Fa("mainScrollAnimComplete",qc),Fa("initialZoomInEnd",qc),Fa("destroy",function(){for(var a,b=0;b<_b.length;b++)a=_b[b],
// remove reference to DOM elements, for GC
a.container&&(a.container=null),a.placeholder&&(a.placeholder=null),a.img&&(a.img=null),a.preloader&&(a.preloader=null),a.loadError&&(a.loaded=a.loadError=!1);hc=null})},getItemAt:function(a){return a>=0&&(void 0!==_b[a]&&_b[a])},allowProgressiveImg:function(){
// 1. Progressive image loading isn't working on webkit/blink
//    when hw-acceleration (e.g. translateZ) is applied to IMG element.
//    That's why in PhotoSwipe parent element gets zoom transform, not image itself.
//
// 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.
//    That's why it's disabled on touch devices (mainly because of swipe transition)
//
// 3. Progressive image loading sometimes doesn't work in IE (up to 11).
// Don't allow progressive loading on non-large touch devices
return i.forceProgressiveLoading||!G||i.mouseUsed||screen.width>1200},setContent:function(a,b){i.loop&&(b=Da(b));var c=f.getItemAt(a.index);c&&(c.container=null);var d,g=f.getItemAt(b);if(!g)return void(a.el.innerHTML="");
// allow to override data
Ga("gettingData",b,g),a.index=b,a.item=g;
// base container DIV is created only once for each of 3 holders
var h=g.container=e.createEl("pswp__zoom-wrap");if(!g.src&&g.html&&(g.html.tagName?h.appendChild(g.html):h.innerHTML=g.html),oc(g),lc(g,ra),!g.src||g.loadError||g.loaded)g.src&&!g.loadError&&(
// image object is created every time, due to bugs of image loading & delay when switching images
d=e.createEl("pswp__img","img"),d.style.opacity=1,d.src=g.src,pc(g,d),mc(b,g,h,d,!0));else{if(g.loadComplete=function(c){
// gallery closed before image finished loading
if(j){
// check if holder hasn't changed while image was loading
if(a&&a.index===b){if(oc(c,!0))
// recalculate dimensions
return c.loadComplete=c.img=null,lc(c,ra),La(c),void(a.index===m&&f.updateCurrZoomItem());c.imageAppended?
// remove preloader & mini-img
!bc&&c.placeholder&&(c.placeholder.style.display="none",c.placeholder=null):N.transform&&(ga||bc)?hc.push({item:c,baseDiv:h,img:c.img,index:b,holder:a,clearPlaceholder:!0}):mc(b,c,h,c.img,ga||bc,!0)}c.loadComplete=null,c.img=null,// no need to store image element after it's added
Ga("imageLoadComplete",b,c)}},e.features.transform){var k="pswp__img pswp__img--placeholder";k+=g.msrc?"":" pswp__img--placeholder--blank";var l=e.createEl(k,g.msrc?"img":"");g.msrc&&(l.src=g.msrc),pc(g,l),h.appendChild(l),g.placeholder=l}g.loading||nc(g),f.allowProgressiveImg()&&(
// just append image
!ac&&N.transform?hc.push({item:g,baseDiv:h,img:g.img,index:b,holder:a}):mc(b,g,h,g.img,!0,!0))}ac||b!==m?La(g):(fa=h.style,fc(g,d||g.img)),a.el.innerHTML="",a.el.appendChild(h)},cleanSlide:function(a){a.img&&(a.img.onload=a.img.onerror=null),a.loaded=a.loading=a.img=a.imageAppended=!1}}});/*>>items-controller*/
/*>>tap*/
/**
 * tap.js:
 *
 * Displatches tap and double-tap events.
 * 
 */
var rc,sc={},tc=function(a,b,c){var d=document.createEvent("CustomEvent"),e={origEvent:a,target:a.target,releasePoint:b,pointerType:c||"touch"};d.initCustomEvent("pswpTap",!0,!0,e),a.target.dispatchEvent(d)};Ca("Tap",{publicMethods:{initTap:function(){Fa("firstTouchStart",f.onTapStart),Fa("touchRelease",f.onTapRelease),Fa("destroy",function(){sc={},rc=null})},onTapStart:function(a){a.length>1&&(clearTimeout(rc),rc=null)},onTapRelease:function(a,b){if(b&&!Z&&!X&&!cb){var c=b;if(rc&&(clearTimeout(rc),rc=null,Ab(c,sc)))return void Ga("doubleTap",c);if("mouse"===b.type)return void tc(a,b,"mouse");var d=a.target.tagName.toUpperCase();
// avoid double tap delay on buttons and elements that have class pswp__single-tap
if("BUTTON"===d||e.hasClass(a.target,"pswp__single-tap"))return void tc(a,b);Pa(sc,c),rc=setTimeout(function(){tc(a,b),rc=null},300)}}}});/*>>tap*/
/*>>desktop-zoom*/
/**
 *
 * desktop-zoom.js:
 *
 * - Binds mousewheel event for paning zoomed image.
 * - Manages "dragging", "zoomed-in", "zoom-out" classes.
 *   (which are used for cursors and zoom icon)
 * - Adds toggleDesktopZoom function.
 * 
 */
var uc;Ca("DesktopZoom",{publicMethods:{initDesktopZoom:function(){L||(G?
// if detected hardware touch support, we wait until mouse is used,
// and only then apply desktop-zoom features
Fa("mouseUsed",function(){f.setupDesktopZoom()}):f.setupDesktopZoom(!0))},setupDesktopZoom:function(b){uc={};var c="wheel mousewheel DOMMouseScroll";Fa("bindEvents",function(){e.bind(a,c,f.handleMouseWheel)}),Fa("unbindEvents",function(){uc&&e.unbind(a,c,f.handleMouseWheel)}),f.mouseZoomedIn=!1;var d,g=function(){f.mouseZoomedIn&&(e.removeClass(a,"pswp--zoomed-in"),f.mouseZoomedIn=!1),s<1?e.addClass(a,"pswp--zoom-allowed"):e.removeClass(a,"pswp--zoom-allowed"),h()},h=function(){d&&(e.removeClass(a,"pswp--dragging"),d=!1)};Fa("resize",g),Fa("afterChange",g),Fa("pointerDown",function(){f.mouseZoomedIn&&(d=!0,e.addClass(a,"pswp--dragging"))}),Fa("pointerUp",h),b||g()},handleMouseWheel:function(a){if(s<=f.currItem.fitRatio)
// close PhotoSwipe
// if browser supports transforms & scroll changed enough
return i.modal&&(!i.closeOnScroll||cb||W?a.preventDefault():E&&Math.abs(a.deltaY)>2&&(l=!0,f.close())),!0;if(
// allow just one event to fire
a.stopPropagation(),
// https://developer.mozilla.org/en-US/docs/Web/Events/wheel
uc.x=0,"deltaX"in a)1===a.deltaMode?(
// 18 - average line height
uc.x=18*a.deltaX,uc.y=18*a.deltaY):(uc.x=a.deltaX,uc.y=a.deltaY);else if("wheelDelta"in a)a.wheelDeltaX&&(uc.x=-.16*a.wheelDeltaX),a.wheelDeltaY?uc.y=-.16*a.wheelDeltaY:uc.y=-.16*a.wheelDelta;else{if(!("detail"in a))return;uc.y=a.detail}Va(s,!0);var b=qa.x-uc.x,c=qa.y-uc.y;
// only prevent scrolling in nonmodal mode when not at edges
(i.modal||b<=ea.min.x&&b>=ea.max.x&&c<=ea.min.y&&c>=ea.max.y)&&a.preventDefault(),
// TODO: use rAF instead of mousewheel?
f.panTo(b,c)},toggleDesktopZoom:function(b){b=b||{x:ra.x/2+ta.x,y:ra.y/2+ta.y};var c=i.getDoubleTapZoom(!0,f.currItem),d=s===c;f.mouseZoomedIn=!d,f.zoomTo(d?f.currItem.initialZoomLevel:c,b,333),e[(d?"remove":"add")+"Class"](a,"pswp--zoomed-in")}}});/*>>desktop-zoom*/
/*>>history*/
/**
 *
 * history.js:
 *
 * - Back button to close gallery.
 * 
 * - Unique URL for each slide: example.com/&pid=1&gid=3
 *   (where PID is picture index, and GID and gallery index)
 *   
 * - Switch URL when slides change.
 * 
 */
var vc,wc,xc,yc,zc,Ac,Bc,Cc,Dc,Ec,Fc,Gc,Hc={history:!0,galleryUID:1},Ic=function(){return Fc.hash.substring(1)},Jc=function(){vc&&clearTimeout(vc),xc&&clearTimeout(xc)},
// pid - Picture index
// gid - Gallery index
Kc=function(){var a=Ic(),b={};if(a.length<5)// pid=1
return b;var c,d=a.split("&");for(c=0;c<d.length;c++)if(d[c]){var e=d[c].split("=");e.length<2||(b[e[0]]=e[1])}if(i.galleryPIDs){
// detect custom pid in hash and search for it among the items collection
var f=b.pid;// if custom pid cannot be found, fallback to the first item
for(b.pid=0,c=0;c<_b.length;c++)if(_b[c].pid===f){b.pid=c;break}}else b.pid=parseInt(b.pid,10)-1;return b.pid<0&&(b.pid=0),b},Lc=function(){if(xc&&clearTimeout(xc),cb||W)
// changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation
// that's why we update hash only when no animations running
return void(xc=setTimeout(Lc,500));yc?clearTimeout(wc):yc=!0;var a=m+1,b=cc(m);b.hasOwnProperty("pid")&&(
// carry forward any custom pid assigned to the item
a=b.pid);var c=Bc+"&gid="+i.galleryUID+"&pid="+a;Cc||Fc.hash.indexOf(c)===-1&&(Ec=!0);var d=Fc.href.split("#")[0]+"#"+c;Gc?"#"+c!==window.location.hash&&history[Cc?"replaceState":"pushState"]("",document.title,d):Cc?Fc.replace(d):Fc.hash=c,Cc=!0,wc=setTimeout(function(){yc=!1},60)};Ca("History",{publicMethods:{initHistory:function(){if(e.extend(i,Hc,!0),i.history){Fc=window.location,Ec=!1,Dc=!1,Cc=!1,Bc=Ic(),Gc="pushState"in history,Bc.indexOf("gid=")>-1&&(Bc=Bc.split("&gid=")[0],Bc=Bc.split("?gid=")[0]),Fa("afterChange",f.updateURL),Fa("unbindEvents",function(){e.unbind(window,"hashchange",f.onHashChange)});var a=function(){Ac=!0,Dc||(Ec?history.back():Bc?Fc.hash=Bc:Gc?
// remove hash from url without refreshing it or scrolling to top
history.pushState("",document.title,Fc.pathname+Fc.search):Fc.hash=""),Jc()};Fa("unbindEvents",function(){l&&
// if PhotoSwipe is closed by scroll, we go "back" before the closing animation starts
// this is done to keep the scroll position
a()}),Fa("destroy",function(){Ac||a()}),Fa("firstUpdate",function(){m=Kc().pid});var b=Bc.indexOf("pid=");b>-1&&(Bc=Bc.substring(0,b),"&"===Bc.slice(-1)&&(Bc=Bc.slice(0,-1))),setTimeout(function(){j&&// hasn't destroyed yet
e.bind(window,"hashchange",f.onHashChange)},40)}},onHashChange:function(){return Ic()===Bc?(Dc=!0,void f.close()):void(yc||(zc=!0,f.goTo(Kc().pid),zc=!1))},updateURL:function(){
// Delay the update of URL, to avoid lag during transition, 
// and to not to trigger actions like "refresh page sound" or "blinking favicon" to often
Jc(),zc||(Cc?vc=setTimeout(Lc,800):Lc())}}}),/*>>history*/
e.extend(f,hb)};return a});